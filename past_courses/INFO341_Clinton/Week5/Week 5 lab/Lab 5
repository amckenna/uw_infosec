Overview

In this lab, we will learn to use common tools to examine the socket mechanisms that are most often used by applications to create servers or clients. We will also examine application layer protocols more closely in Wireshark.

Before you begin, you may find it helpful to install a command-line version of whois if the tool is not already present (as it is on macOS). On Linux, whois can be installed through your preferred package manager, such as apt-get. Microsoft provides a version of the tool

 

Procedures

The primary tool that we will become familiar with in this lab is netstat. While netstat is present on all major platforms, its syntax and feature set varies by vendor. We'll provide some examples below, but you may run into scenarios which require you to consult local help and online resources associated with your OS. To obtain a summary of command-line options on Windows, run netstat with -?. On Linux or macOS, you can obtain detailed help by running man netstat.

Regardless of which system you are using, netstat will return a bounty of information ranging from the current state of connections on the system to detailed statistics related to protocols and network interfaces. To get you started, let's take a look at the output of the output generated by netstat -an. Depending on your system, you may receive several screens full of data. Scroll to find the section detailing TCP. You should see an entry in the output table for each server or client socket open on your system.

If you haven't done so already, open an SSH connection to your Raspberry Pi. Create a small test.html file in your home directory on the Pi. Launch a web server by executing python -m SimpleHTTPServer. By default, the server will open on port 8000. Verify that the server appears in netstat on your Pi (note that you will not see the server if you omit the -a option).

From your local workstation, open your browser and connect to the server at http://raspberrypi.local:8000/test.html. Compare the output of netstat (on the Pi) after opening this connection to what you saw when you launched the server.

 

Questions

What are the obvious differences between client and server connections (hint: look at the state). List the sockets related to the web server and client connection. Identify both the local and remote IP addresses and ports for each socket.
Review the other TCP processes open on your system. Which states do you observe most frequently?
Review the man page for netstat (Linux/macOS) or search online to identify a full list of socket states.

What state would you expect to see for a client that has not yet received a SYN/ACK response after opening a three-way handshake?
What is the purpose of multiple FIN_WAIT states?
Why do you think these states are missing (probably) from your netstat output?
Let's explore the functionality of netstat a bit further by changing up the options. Observe the time required for netstat -a to complete with and without the -n option. Why is netstat so much faster when you run it with -n?

Which option is used to give you the name of the command that opened the socket on Raspbian? What is the equivalent option on your local machine (on macOS, look into the lsof command for this question).
What output is given by netstat -st (on Raspbian)? How might this output be useful in diagnosing lower-level network issues.
Which option(s) are invoked to list the current routing table (should work across platforms)?
Exploring an Application Layer Protocol

On your workstation, open the editor in which you configured the rmate-compatible extension for Lab 3. Follow the instructions associated with your extension to start the server. In Atom, open the packages menu and navigate to Remote Atom => Start Server.

By default, the server will launch on TCP/52698. Confirm based on the output of netstat that it is running. Record the IP address(es) to which the server is bound. Open a reverse-SSH tunnel to your Pi as described in the prior setup guide: ssh -R 52698:localhost:52698 pi@raspberrypi.local.

Now from within the Pi SSH session, use the rmate command to launch the remote editor. With the file open, examine netstat output on both ends of the connection, i.e., from the Pi and from the workstation.

Record the netstat entries related to these commands. Include the IP addresses, ports, and commands used to launch the socket (be sure to run netstat with sudo for this step).
Notice that on both ends, all communication appears to happen on the loopback address (127.0.0.1/IPv4 or ::1/IPv6). This is unusual, but characteristic of the SSH tunneling feature that rmate relies upon. We can use it to our advantage to see how the rmate protocol is working.

Using Wireshark, capture plaintext rmate traffic on the loopback adapter while you open files, make changes in the remote editor, and save those changes. If you are capturing from Windows, you will need to install npcap to capture on loopback since Windows doesn't provide an adapter in the same manner as Linux and macOS.

Locate the associated packets and examine the structure of the application-level conversation by using the "Follow TCP Stream" functionality in Wireshark.

Provide a high-level description of the major protocol operations and command structure (don't over-complicate).
(EC 1.5pts) 11. Use the clues you've obtained from netstat and Wireshark to spoof the rmate command using telnet from the Pi (e.g., to "edit" a file that doesn't exist. Describe the steps you took and paste a copy of the telnet session in your lab report. Were you able to accomplish anything intereting?

Rubric
